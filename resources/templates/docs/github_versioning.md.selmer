# Versioning

This project uses **Commitizen** and Conventional Commits to manage versions and changelogs.
The bump happens automatically on pushes to main.
The GitHub Action is defined in `.github/workflows/bump.yaml`:

There are three moving parts:

- the `version` field in `pyproject.toml` (the canonical project version)
- git tags (`v0.1.0`, `v0.2.0`, …)
- a GitHub Action that runs Commitizen on every push to `main`

You do **not** bump versions by hand; you write good commit messages and let Commitizen decide the next version.
As soon as you push this repo to GitHub, it will **automatically** show up under the **Actions** tab.
You don't need to manually create a workflow. The only requirement is that you keep the file in the same path.

## What gets versioned

The Commitizen config lives in `pyproject.toml`:

```toml
[tool.commitizen]
name = "cz_conventional_commits"
version = "0.1.0"
version_files = ["pyproject.toml:version"]
update_changelog_on_bump = true
```

This tells Commitizen to:

- use the [conventional commits rules](https://www.conventionalcommits.org/)
- treat [project].version in `pyproject.toml` as the source of truth
- update that field on each bump
- update the changelog automatically when a bump happens

On each successful bump, Commitizen will:

- update `pyproject.toml` with the new version
- append to the changelog
- create a commit with a message starting with bump:
- create a git tag for that version (for example `v0.2.0`)

The workflow uses the repository’s built-in `GITHUB_TOKEN` with `contents: write` permissions,
so you do not need to create a personal access token. The token is injected by GitHub and is
used automatically for checkout, tagging, and pushing the bump commit.

## How Commitizen decides the new version

Commitizen looks at all commits since the last version tag and decides whether to do a major, minor, or patch bump.

With cz_conventional_commits, the default rules are:

- `feat`: ... → minor bump (e.g. `0.1.0` → `0.2.0`)
- `fix`: ... → patch bump (e.g. `0.1.0` → `0.1.1`)
- commits marked as breaking (`BREAKING CHANGE:` in the footer or `feat!:` / `fix!:`) → major bump
- everything else (`docs`, `chore`, `style`, `test`, `build`, `ci`, refactor without `BREAKING CHANGE`) → no bump

## Pre-commit and commit message enforcement

Pre-commit is also wired in to make sure you actually follow the Conventional Commits format.
In `.pre-commit-config.yaml` there is a Commitizen hook configured for the `commit-msg` stage.
