# Versioning

This project uses **Commitizen** and Conventional Commits to manage versions and changelogs.
The bump happens automatically on pushes to main.
The GitHub Action is defined in `.github/workflows/bump.yaml`:

There are three moving parts:

- the `version` field in `pyproject.toml` (the canonical project version)
- git tags (`v0.1.0`, `v0.2.0`, …)
- a GitHub Action that runs Commitizen on every push to `main`

You do **not** bump versions by hand; you write good commit messages and let Commitizen decide the next version.
As soon as you push this repo to GitHub, it will **automatically** show up under the **Actions** tab.
You don't need to manually create a workflow. The only requirement is that you keep the file in the same path.

## What gets versioned

The Commitizen config lives in `pyproject.toml`:

```toml
[tool.commitizen]
name = "cz_conventional_commits"
version = "0.1.0"
version_files = ["pyproject.toml:version"]
update_changelog_on_bump = true
```

This tells Commitizen to:

- use the [conventional commits rules](https://www.conventionalcommits.org/)
- treat [project].version in `pyproject.toml` as the source of truth
- update that field on each bump
- update the changelog automatically when a bump happens

On each successful bump, Commitizen will:

- update `pyproject.toml` with the new version
- append to the changelog
- create a commit with a message starting with bump:
- create a git tag for that version (for example `v0.2.0`)

The Github Action expects a repo secret called `PERSONAL_ACCESS_TOKEN`:

```yaml
with:
  github_token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
```

This secret needs permissions to:

- read/write the repo
- create tags

To create a token:

1. In GitHub, go to your profile → **Settings** → **Developer settings** → **Personal access tokens** and
generate a new fine-grained token with read/write access to this repository.
2. In GitHub, go to your repository → Settings → Secrets and variables → Actions and create this [repository secret](https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secrets?utm_source=chatgpt.com):

- `PERSONAL_ACCESS_TOKEN`

The token is used by the action for both checkout and pushing the bump commit + tag.
If it is missing or under-scoped, the job will fail when it tries to push. Make sure 
the token has read and write access to actions and code.

## How Commitizen decides the new version

Commitizen looks at all commits since the last version tag and decides whether to do a major, minor, or patch bump.

With cz_conventional_commits, the default rules are:

- `feat`: ... → minor bump (e.g. `0.1.0` → `0.2.0`)
- `fix`: ... → patch bump (e.g. `0.1.0` → `0.1.1`)
- commits marked as breaking (`BREAKING CHANGE:` in the footer or `feat!:` / `fix!:`) → major bump
- everything else (`docs`, `chore`, `style`, `test`, `build`, `ci`, refactor without `BREAKING CHANGE`) → no bump

## Pre-commit and commit message enforcement

Pre-commit is also wired in to make sure you actually follow the Conventional Commits format.
In `.pre-commit-config.yaml` there is a Commitizen hook configured for the `commit-msg` stage.
